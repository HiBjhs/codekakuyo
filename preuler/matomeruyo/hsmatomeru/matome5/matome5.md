はい  
### リスト内包表記
```
[x^2 | x <- [1..5]]

```
こういうやつ
[(x,y) | x <- [1,2,3], y <- [4,5]]  
xとyから一つずつ取り出してきて一つの組み合わせにする  


### ガード
```
[x | x <- [1..10], even x]
```
こういうやつ  
入れる値をあとの条件で間引く  

```
factors :: Int -> [Int]
factors n = [x | x <- [1..n], n `mod` x == 0]

prime :: Int -> Bool
prime n = factors n == [1,n] --素数判定
```
### zip
例えば  >zip ['a','b','c'] [1,2,3,4]  
[('a',1),('b',2),('c',3)]  

```
positions :: Eq a => a -> [a] -> [Int]
positions x xs = [i | (x',i) <- zip xs [0..], x == x']
```
xsの要素分0から個数分zipして鍵となる値xを生成されたペアに対して適用していきTrueだったらペアとして残るiの値で何番目かわかるで返す値はi  
こういう定義の時[0..]は無限リストだけどzipするリスト分しかないのでこの文脈では扱える  
### 文字列
"abc":Stringのような文字列は実際には合成された文字のリスト分解すると['a','b','c'] :: [Char] こうなる
u 例えば文字列を受け取って指定された文字が何回登場しているかを数える *** count ***
```
count :: Char -> String -> Int
count x xs = length [x' | x' <- xs, x == x']
```
countは鍵となるchar型の一文字が何回x'に文字列xsから入れられるかのlength(リストの長さを出す)で何回入れられているのかをみる  
シーザー暗号とは後ろ構え化にアルファベットを何文字かずらすことでもとの文がなんなのかを隠す    
aaa
